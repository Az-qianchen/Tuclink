[{"content":"Sketchfab 直切主题，第一个要介绍的网站是 Sketchfab\nSketchfab 算是最为优质的 3D 资产网站之一了，上面有海量的付费和免费资产，模型还能直接 3D 预览\n如果你是 3D 艺术家，Sketchfab 也可以用作模型展示和售卖 Sketchfab 链接 要注意的是，如果希望筛选免费商用模型，LICENSES（许可证）需要勾选 CC BY、CC BY-SA、CC BY-ND、CC0、Free Standard\n其资产不仅数量多，免费内容的质量也绝对是第一梯队的\nSketchfab-PlantCatalog（植物） 顺带再介绍一下 PlantCatalog\n其制作团队 e-on software 最近免费开放了三款产品 一款是类似于 GAEA（官网） 的程序环境生成软件 VUE（介绍） 一款是类似于 SpeedTree（官网） 的程序植物生成软件 PlantFactory（介绍） 还有一款就是高精度的植物素材包 PlantCatalog（介绍）官网下载\nPlantCatalog的模型也被上架到了 Sketchfab 上，可以直接下载，数量还是很可观的足足 3000+ 同时如果配合 PlantFactory 还可以进行更多的参数调整\n详情的话就请见官方视频了 How to use PlantCatalog，不过和官方流程配合的比较好的还是 Unreal，Maya 之类，Godot 和 Unity 使用，植被动画可能就没有那么方便了\n可以免费的用于商业用途，只是官方不再会进行后续的更新 Three D Scans（雕塑） Three D Scans这个网站提供了一组高精度的雕塑扫描模型，数量并不是太多，但是各个都非常的精美 其不受任何版权限制可以自由使用（协议信息） Poly Haven Poly Haven这个网站被推荐的应该还是比较多的，网站上除了模型还有贴图资产和环境贴图资产（HDRI） 且全部使用 CC0 协议可以自由使用（协议信息） Poliigon Poliigon这个网站本质是个 3D 资产商城，但是上面也有着一些免费的 3D 资产，同样除了模型还有贴图资产和环境贴图资产（HDRI），虽然数量有限，但是质量都还还挺高的 且免费许可证同样允许商用（协议信息） Cgtrader Cgtrader同样是个模型商城，但是包含近万的免费模型，模型的内容也是十分优质，虽然算是各种类型都有，但是室内设计相关的模型居多 资源可商用，但需要注意的是不能用于 AI 训练 Archiup（室内设计） Archiup包含 10万+ 的免费资产，但是需要注意格式，其主要为室内设计相关的模型和贴图资产 但值得注意的是协议最后有补充到：“管理员不保证网站和资源的内容可用或符合波兰共和国以外国家的当地法律。使用本网站，您需自行承担风险，并负责遵守适用的当地法律。” 具体细则请仔细阅读条款（网站协议） Design Connected（室内设计） Design Connected是个资产销售平台，但提供了 400+ 的免费模型资产，主要为室内设计相关的模型 网站协议并未明确指明可用于游戏使用，因此具体细则请仔细阅读条款，并进行咨询（网站协议） ","permalink":"https://post.tuclink.com/zh/post/tool/model-asset/","summary":"10万+ 免费商用模型【精选优质资产网站】实现模型自由","title":"10万+ 免费商用模型【精选优质资产网站】"},{"content":"软件官网\n材质资源\n软件文档\n下载地址 itch\n下载地址 github\n简介 Material Maker 他是一个由 Godot 制作的材质编辑器，功能类似于 Substance Designer\n是一个 MIT 协议的开源软件，也就是说不仅仅他是免费的，还可以用他的源码做任何事情\n他的软件压缩包更是只有 40MB 大小，且无需安装，解压后，就可以直接运行\n页面元素也非常简单，且带有中文翻译，就是开始时需要设置一下，我想使用他你会得到比在游戏引擎中编写材质更直观也更便捷的体验\nMaterial Maker 本身就带有非常多的预设节点，且随着更新还在逐渐的添加\n其制作的材质可以以贴图或是着色器脚本的格式，导入到其他的软件中直接使用，例如 Godot、Unity、Unreal、Blender\n不过值得注意的是着色器脚本并不直接支持 Blender 的导出，因为 Blender 并不支持着色器脚本的使用\n","permalink":"https://post.tuclink.com/zh/post/tool/material-maker/","summary":"1000+ 免费材质分享【Material Maker】（适用于 Godot、Unity、Unreal、Blender）","title":"Material Maker 种草"},{"content":" 使用演示 实现解析 着色器脚本（矩形） shader_type spatial; render_mode unshaded, depth_draw_never, skip_vertex_transform; uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest; // 深度贴图 uniform sampler2D gradient_texture : repeat_disable; instance uniform vec3 range = vec3(1.0); // 范围 uniform float camera_near = 0.05; //（设为相机近平面距离） void vertex() { // 顶点变换到视图空间 vec4 VIEW_VERTEX = MODELVIEW_MATRIX * vec4(VERTEX, 1.0); // 确保在放大时网格不被近平面剪裁 VIEW_VERTEX.z = min(VIEW_VERTEX.z, -camera_near); VERTEX = VIEW_VERTEX.xyz; } void fragment() { // https://docs.godotengine.org/zh-cn/4.x/tutorials/shaders/advanced_postprocessing.html#depth-texture float depth = texture(depth_texture, SCREEN_UV).x; // 获取深度纹理 vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); // xy 原点轴屏幕居中 vec4 world = INV_VIEW_MATRIX * INV_PROJECTION_MATRIX * vec4(ndc, 1.0); vec3 world_position = world.xyz / world.w; // 获取世界坐标 // 将世界坐标转换为物体的局部坐标 vec3 local_position = (inverse(MODEL_MATRIX) * vec4(world_position, 1.0)).xyz; // //// 计算物体局部坐标系中的距离 vec3 center_distance = abs(local_position); // 使用局部坐标 if (center_distance.x \u0026gt;= range.x || center_distance.y \u0026gt;= range.y || center_distance.z \u0026gt;= range.z) discard; // 剪切范围外像素 center_distance = 1.0 - center_distance / range; // 计算映射 vec4 gradient = texture(gradient_texture, vec2(center_distance.x * center_distance.y * center_distance.z)); // 映射过度 // ALBEDO = gradient.rgb; ALPHA = gradient.a; //ALBEDO = vec3(center_distance.x * center_distance.y * center_distance.z); //ALBEDO = vec3(center_distance.x); } 着色器脚本（圆形） shader_type spatial; render_mode unshaded, depth_draw_never, skip_vertex_transform; uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest; // 深度贴图 uniform sampler2D gradient_texture : repeat_disable; instance uniform float range = 1.0; // 范围 uniform float camera_near = 0.05; //（设为相机近平面距离） void vertex() { // 顶点变换到视图空间 vec4 VIEW_VERTEX = MODELVIEW_MATRIX * vec4(VERTEX, 1.0); // 确保在放大时网格不被近平面剪裁 VIEW_VERTEX.z = min(VIEW_VERTEX.z, -camera_near); VERTEX = VIEW_VERTEX.xyz; } void fragment() { // https://docs.godotengine.org/zh-cn/4.x/tutorials/shaders/advanced_postprocessing.html#depth-texture float depth = texture(depth_texture, SCREEN_UV).x; // 获取深度纹理 vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); // xy 原点轴屏幕居中 vec4 world = INV_VIEW_MATRIX * INV_PROJECTION_MATRIX * vec4(ndc, 1.0); vec3 world_position = world.xyz / world.w; // 获取世界坐标 float center_distance = distance(NODE_POSITION_WORLD, world_position); // 相对于物体的距离 if (center_distance \u0026gt;= range) discard; // 剪切范围外像素 vec4 gradient = texture(gradient_texture, vec2(center_distance / range)); // 映射过度 ALBEDO = gradient.rgb; ALPHA = gradient.a; //ALBEDO = vec3(world_position.z); } 着色器脚本（锥形） shader_type spatial; render_mode unshaded, depth_draw_never, skip_vertex_transform; uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest; // 深度贴图 uniform sampler2D gradient_texture : repeat_disable; instance uniform float range = 1.0; // 范围 instance uniform float cone_angle = 30; // 锥形的角度 uniform float camera_near = 0.05; //（设为相机近平面距离） void vertex() { // 顶点变换到视图空间 vec4 VIEW_VERTEX = MODELVIEW_MATRIX * vec4(VERTEX, 1.0); // 确保在放大时网格不被近平面剪裁 VIEW_VERTEX.z = min(VIEW_VERTEX.z, -camera_near); VERTEX = VIEW_VERTEX.xyz; } void fragment() { float radian = radians(cone_angle); // https://docs.godotengine.org/zh-cn/4.x/tutorials/shaders/advanced_postprocessing.html#depth-texture float depth = texture(depth_texture, SCREEN_UV).x; // 获取深度纹理 vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); // xy 原点轴屏幕居中 vec4 world = INV_VIEW_MATRIX * INV_PROJECTION_MATRIX * vec4(ndc, 1.0); vec3 world_position = world.xyz / world.w; // 获取世界坐标 // 将世界坐标转换为物体的局部坐标 vec3 local_position = (inverse(MODEL_MATRIX) * vec4(world_position, 1.0)).xyz; vec3 direction_to_fragment = normalize(world_position - NODE_POSITION_WORLD); // 计算圆 float center_distance = distance(NODE_POSITION_WORLD, world_position); // 相对于物体的距离 if (center_distance \u0026gt;= range) discard; // 剪切范围外像素 // 计算从物体中心到片段的方向 vec3 object_up_direction = normalize(mat3(MODEL_MATRIX) * vec3(0.0, 1.0, 0.0)); // 计算方向向量之间的点积，并通过反余弦函数获取角度 float angle = acos(dot(direction_to_fragment, object_up_direction)); // 如果角度大于锥角，则丢弃片段 if (angle \u0026gt; radian)discard; vec4 gradient = texture(gradient_texture, vec2((1.0 - (angle / PI) / (radian / PI)) * (1.0 - center_distance / range))); // 映射过度 if ((1.0 - (angle / PI) / (radian / PI)) * (1.0 - center_distance / range) \u0026lt;= 0.0)discard; ALBEDO = gradient.rgb; ALPHA = gradient.a; //ALBEDO = vec3( (1.0 - (angle / PI) / (radian / PI)) * (1.0 - center_distance / range) ); //ALBEDO = vec3(world_position.z); } 着色器脚本（距离场） shader_type spatial; render_mode unshaded, depth_draw_never, skip_vertex_transform; uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest; // 深度贴图 uniform sampler2D gradient_texture : repeat_disable; instance uniform float angle = 30.0; // 锥形的顶角度 instance uniform vec3 range = vec3(1.0); // 范围 instance uniform float rounded = 1.0; // 圆角 uniform float camera_near = 0.05; //（设为相机近平面距离） // https://iquilezles.org/articles/distfunctions/ // p：点的位置 b：盒子尺寸 r：圆角半径 float sdRoundBox( vec3 p, vec3 b, float r ) { // 距离场 max 取正值 min 取负值 vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; } float sdCone( vec3 p,vec2 c) { vec2 q = vec2( length(p.xz), -p.y ); float d = length(q-c*max(dot(q,c), 0.0)); return d * ((q.x*c.y-q.y*c.x\u0026lt;0.0)?-1.0:1.0); } void vertex() { // 顶点变换到视图空间 vec4 VIEW_VERTEX = MODELVIEW_MATRIX * vec4(VERTEX, 1.0); // 确保在放大时网格不被近平面剪裁 VIEW_VERTEX.z = min(VIEW_VERTEX.z, -camera_near); VERTEX = VIEW_VERTEX.xyz; } void fragment() { // https://docs.godotengine.org/zh-cn/4.x/tutorials/shaders/advanced_postprocessing.html#depth-texture float depth = texture(depth_texture, SCREEN_UV).x; // 获取深度纹理 vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); // xy 原点轴屏幕居中 vec4 world = INV_VIEW_MATRIX * INV_PROJECTION_MATRIX * vec4(ndc, 1.0); vec3 world_position = world.xyz / world.w; // 获取世界坐标 // 将世界坐标转换为物体的局部坐标 vec3 local_position = (inverse(MODEL_MATRIX) * vec4(world_position, 1.0)).xyz; // 距离场 float radian = radians(angle/2.0); float center_distance = max(sdRoundBox(local_position, range-rounded, rounded),sdCone(local_position, vec2(sin(radian),cos(radian)))); if (angle \u0026lt;= 360.0){ center_distance = max(sdRoundBox(local_position, range-rounded, rounded),sdCone(local_position, vec2(sin(radian),cos(radian)))); }else{ center_distance = sdRoundBox(local_position, range-rounded, rounded); } if (center_distance \u0026gt;= 0.0) discard; // 剪切范围外像素 vec4 gradient = texture(gradient_texture, vec2(-center_distance)); // 映射过度 ALBEDO = gradient.rgb; ALPHA = gradient.a; //ALBEDO = vec3(center_distance.x * center_distance.y * center_distance.z); //ALBEDO = vec3(world_position.z); } 着色器脚本（后处理） shader_type spatial; render_mode unshaded, depth_draw_never; uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest; // 深度贴图 uniform sampler2D gradient_texture : repeat_disable; instance uniform vec3 position; // 位置 instance uniform float range = 1.0; // 范围 uniform float camera_near = 0.05; //（设为相机近平面距离） void fragment() { // https://docs.godotengine.org/zh-cn/4.x/tutorials/shaders/advanced_postprocessing.html#depth-texture float depth = texture(depth_texture, SCREEN_UV).x; // 获取深度纹理 vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); // xy 原点轴屏幕居中 vec4 world = INV_VIEW_MATRIX * INV_PROJECTION_MATRIX * vec4(ndc, 1.0); vec3 world_position = world.xyz / world.w - position; // 获取世界坐标 float center_distance = distance(NODE_POSITION_WORLD, world_position); // 相对于物体的距离 if (center_distance \u0026gt;= range) discard; // 剪切范围外像素 vec4 gradient = texture(gradient_texture, vec2(center_distance / range)); // 映射过度 ALBEDO = gradient.rgb; ALPHA = gradient.a; //ALBEDO = vec3(world_position.z); } 网格脚本（后处理） @tool extends MeshInstance3D @export var target: Node3D func _process(delta: float) -\u0026gt; void: set_instance_shader_parameter(\u0026#34;position\u0026#34;, target.global_position - global_position) ","permalink":"https://post.tuclink.com/zh/post/shader/shader-5/","summary":"Godot Shader 分享","title":"Godot Shader 范围指示器"},{"content":"参考了这篇文章和这篇文章\nhugo 版本要大于 v0.122.0\n将以下脚本放在 layouts/partials/ 文件夹中的一个模板中，例如 extend_footer.html\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 在配置文件 config.yaml 中添加以下配置\nmarkup: goldmark: extensions: passthrough: delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) - - $ - $ enable: true 现在就能成功渲染数学公式了\n\\begin{aligned} KL(\\hat{y} || y) \u0026amp;= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\ JS(\\hat{y} || y) \u0026amp;= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned}\n使用时如果需要使用内联方程，即直接将公式嵌入文本如：\\(E=mc^2\\)\n不能使用\n$E=mc^2$ 需要使用\n\\\\(E=mc^2\\\\) ","permalink":"https://post.tuclink.com/zh/post/hugo/hugo-math/","summary":"使用 mathjax 添加 latex 公式支持","title":"Hugo 添加数学公式支持"},{"content":" 打开任务管理器 找到资源管理器 右键选择重新启动 ","permalink":"https://post.tuclink.com/zh/post/tips/win-11/","summary":"解决 Win 11 右下角设置面板老是无法打开的问题","title":"Win 11 右下角设置面板无法打开"},{"content":" 点乘 A向量 在 B向量 上的投影乘以 B向量 的长度 叉乘 垂直于 AB向量平面的单位向量（紫色向量） 三角函数 函数 缩写 表达式 正弦函数 sin ∠A的对边比斜边 余弦函数 cos ∠A的邻边比斜边 正切函数 tan ∠A的对边比邻边 毕达哥拉斯定理（勾股定理） 命题：在一个直角三角形中，斜边的平方等于其他两边的平方之和\n\\(a^2 + b^2 = c^2\\)\n复数 虚数：i 虚数：\\(i^2=-1\\) 复数包含实数和虚数 复数：$z=a+bi$ 复平面：水平的实轴与垂直的虚轴建立起来的复数的几何表示 模 复数的模 设复数为：\\(z=a+bi\\) 复数 z 的模：\\(|z|=\\sqrt{a^2+b^2}\\) 集合意义为：复平面上一点 (a,b) 到原点的距离 取模运算 取余数 例：100%17=15 ∑（西格玛） 求和符号 $$\\sum_{i=1}^n f(i)$$ 下标 “i” 为起始值 上标 “n” 为结束值 右边 “$f(i)$” 为求和对象：为一个包含 “i” 的函数 求和过程为：将求和对象 “\\(f(i)\\)” ​的值从起始值 “i=1” 到结束值 “i=n” 相加，得到最终的求和结果 $$\\sum_{i=1}^5 i$$ 计算过程等于：1+2+3+4+5=15\n幂（power） 乘方运算的结果 $2^3$ 等于 2 的 3 次幂 等于 2 的 3 次方 2 为“底数” 3 为“指数”\n数 自然数（N） 0，1，2，3 \u0026hellip;\n正整数集（${N^+}$ or ${N^*}$） 1，2，3，4\u0026hellip;\n整数集（Z） -2，-1，0，1，2\u0026hellip;\n有理数集（Q） 非无限不循环小数，如：$\\pi$ 、$\\sqrt{2}$\n实数（R） 正数，0，复数（包含小数）\n四元数 表示为：a+bi+cj+dk = w、x、y、z 其中 i、j、k 为虚数 通过四维空间描述三维旋转的方法 x、y、z 可以理解为三轴的权重 w 为 靠近圆心的比值 1 为圆形，0为球面，-1为无穷远\n矩阵 左乘 表示向量坐标变换至矩阵坐标系（向量坐标改变）\n$$ \\begin{bmatrix} a1 \u0026amp; a2 \u0026amp; a3\\\\ b1 \u0026amp; b2 \u0026amp; b3\\\\ c1 \u0026amp; c2 \u0026amp; c3 \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z \\end{bmatrix} =x \\begin{bmatrix} a1\\\\ b1\\\\ c1 \\end{bmatrix} +y \\begin{bmatrix} a2\\\\ b2\\\\ c2 \\end{bmatrix} +z \\begin{bmatrix} a3\\\\ b3\\\\ c3 \\end{bmatrix} = \\begin{bmatrix} xa1 \u0026amp; ya2 \u0026amp; za3\\\\ xb1 \u0026amp; yb2 \u0026amp; zb3\\\\ xc1 \u0026amp; yc2 \u0026amp; zc3 \\end{bmatrix} $$\n右乘 表示在矩阵坐标系中向量的坐标（向量坐标不变） $$\n\\begin{bmatrix}\nx \\\\ y \\\\ z\n\\end{bmatrix}\n\\begin{bmatrix}\na1 \u0026amp; b1 \u0026amp; c1 \\\\ a2 \u0026amp; b2 \u0026amp; c2 \\\\ a3 \u0026amp; b3 \u0026amp; c3\n\\end{bmatrix} =x\n\\begin{bmatrix}\na1 \\\\ a2 \\\\ a3\n\\end{bmatrix} +y\n\\begin{bmatrix}\nb1 \\\\ b2 \\\\ b3\n\\end{bmatrix} +z\n\\begin{bmatrix}\nc1 \\\\ c2 \\\\ c3\n\\end{bmatrix} = \\begin{bmatrix}\nxa1 + yb1 + zc1 \\\\ xa2 + yb2 + zc2 \\\\ xa3 + yb3 + zc3\n\\end{bmatrix}\n$$\n傅里叶变换 对时域的频域拆解 时域：信号的时间变化 频域：信号分解出的信号（三角函数正弦信号） 相位：起始点位置 振幅：波动的强度 低频（决定轮廓） 高频（决定细节）\n","permalink":"https://post.tuclink.com/zh/post/collect/math/","summary":"主要是与着色器相关的一些数学知识点","title":"数学知识"},{"content":" 使用演示 实现解析 着色器脚本 shader_type spatial; render_mode cull_disabled; //禁用面剔除 uniform float sway = 0.5; //摆动强度 uniform float bent = 0.2; //弯曲幅度 uniform float scale = 0.01; //噪音缩放比例 uniform float time_scale =0.1; //速度 uniform vec3 sway_dir = vec3(1.0,0.0,1.0); //风力方向 uniform float color_scale = 0.04; //颜色强度 uniform vec4 top_color : source_color; //顶部颜色 uniform vec4 bot_color : source_color; //底部颜色 uniform sampler2D sway_noise; //噪音贴图 varying vec3 vert; //储存初始位置 void vertex() //摆动计算 { vert = VERTEX; //储存初始位置 NORMAL = vec3(0.0, 1.0, 0.0); // 统一法向 vec4 sway_dir_world = vec4(sway_dir, 0.0) * MODEL_MATRIX; // 将风力方向由模型空间转换为世界空间（统一朝向） vec3 world_vertex = (MODEL_MATRIX * vec4(VERTEX,1.0)).xyz; // 顶点在世界空间的位置(充当 UV) float curent_wind = texture(sway_noise, world_vertex.xz * scale - TIME * time_scale * sway_dir.xz).x; //根据世界位置采样风力噪声贴图,得到风力值 VERTEX.xz += normalize(sway_dir_world.xz) * sway * curent_wind * VERTEX.y; //根据风力值和高度,在风力方向上偏移顶点位置 VERTEX.y -= VERTEX.y * bent * length(vec2(VERTEX.x, VERTEX.z)); // 根据x轴位置,使顶点上下摆动 } void fragment() // 颜色和粗糙度计算 { ALBEDO = mix(bot_color, top_color, clamp(vert.y * color_scale, 0.0, 1.0)).xyz; NORMAL *= FRONT_FACING ? 1.0 : -1.0; // 是否面朝相机设置法相 } 草的面片模型 模型 在该页面按下 Ctrl + Shift + S 键，即可下载该模型\n","permalink":"https://post.tuclink.com/zh/post/shader/shader-4/","summary":"Godot Shader 分享","title":"Godot Shader 面片草地效果"},{"content":"图片来源 小岛工作室官网\n因为官网的图片都存在压缩，且原图大多在 推特 上，故此精选了一部分进行转存\n\u003c!DOCTYPE html\u003e\r","permalink":"https://post.tuclink.com/zh/post/picture/death-stranding/","summary":"图片","title":"死亡搁浅摄影收集"},{"content":" 使用演示 实现解析 用在网格节点上的脚本 @tool extends MeshInstance3D @onready var max_layer = 16 # 总共层数 @onready var next_layer = [] # 生成材质层数 func _ready(): # 存在材质 if material_override: # 获取旧材质 var color = material_override.get_shader_parameter(\u0026#34;base_color\u0026#34;) var stress_tex = material_override.get_shader_parameter(\u0026#34;stress_tex\u0026#34;) var voronoi_tex = material_override.get_shader_parameter(\u0026#34;voronoi_tex\u0026#34;) var mask_tex = material_override.get_shader_parameter(\u0026#34;mask_tex\u0026#34;) # 生成多层材质 for i in range(max_layer): var l = ShaderMaterial.new() l.shader = material_override.shader l.set_shader_parameter(\u0026#34;base_color\u0026#34;,color) l.set_shader_parameter(\u0026#34;mask_tex\u0026#34;,mask_tex) l.set_shader_parameter(\u0026#34;stress_tex\u0026#34;,stress_tex) l.set_shader_parameter(\u0026#34;voronoi_tex\u0026#34;,voronoi_tex) # 设置层顺序 l.set_shader_parameter(\u0026#34;num\u0026#34;,max_layer - i) l.set_render_priority(max_layer - i) if i \u0026gt; 0: l.next_pass = next_layer[i-1] next_layer.append(l) # 添加最后一层 material_override.next_pass = next_layer[max_layer-1] 着色器脚本 shader_type spatial; render_mode cull_back; uniform sampler2D stress_tex : source_color,repeat_enable; // 偏移贴图 uniform sampler2D voronoi_tex : source_color,repeat_enable; // 沃罗诺伊噪声 uniform sampler2D mask_tex : source_color,repeat_enable; // 蒙版贴图 uniform vec3 base_color:source_color; // 基础颜色 uniform float num; //层 uniform float layer_offset = 0.005; // 层偏移 uniform float thick = 600.0; // 影响噪声偏移/噪声尺寸 uniform float step_base = 0.002; // 高度偏移（整体下移） uniform float step_layer = 0.05; // 每层偏移强度（越大越扁） uniform float speed = 0.01; // 动画偏移强度 // 生成伪随机向量 vec2 rand2( vec2 coord ) { // 防止坐标过大的导致的随机性降低 coord = mod(coord, 10000.0); // 返回 x 和 y 在 0-1 之间的伪随机二维向量 return fract(sin( vec2( dot(coord,vec2(127.1,311.7)), dot(coord,vec2(269.5,183.3)) ) ) * 43758.5453); } // 沃罗诺伊噪声 float cellular_noise(vec2 coord) { vec2 i = floor(coord); // 整数部分 vec2 f = fract(coord); // 小数部分 float min_dist = 99999.0; // 为 3x3 的网格各生成一个随机点 for(float x = -1.0; x \u0026lt;= 1.0; x++) { for(float y = -1.0; y \u0026lt;= 1.0; y++) { // 生成随机点 vec2 node = rand2(i + vec2(x, y)) + vec2(x, y); // 勾股定理求斜边 float dist = sqrt(pow((f - node).x, 2.0) + pow((f - node).y, 2.0)); // 限制最大值 min_dist = min(min_dist, dist); } } return min_dist; } void vertex(){ VERTEX += NORMAL * num * layer_offset; //层偏移 } void fragment() { vec2 stress = num * (texture(stress_tex,UV + TIME * speed).rg - 0.5); // 读取噪音图 float voronoi = texture(voronoi_tex,UV + (stress/thick)).r; // 沃罗诺伊偏移 //float voronoi = cellular_noise(UV * thick + stress); // 沃罗诺伊偏移 vec3 mask = texture(mask_tex,UV).rgb; // 读取蒙版图 ALBEDO = base_color * mask; // 设置颜色 ALPHA = max(step(step_base + step_layer * num,(1.0 - voronoi) * mask.r) , step(num,0.5)); // 设置透明度 ROUGHNESS = 0.9; //设置粗糙度 //ALBEDO = vec3(voronoi); } void light() { DIFFUSE_LIGHT += base_color * num * 0.02 * LIGHT_COLOR * ATTENUATION; } 以上为 Godot Shader 代码，有任何问题欢迎进行留言\n","permalink":"https://post.tuclink.com/zh/post/shader/shader-3/","summary":"Godot Shader 分享","title":"Godot Shader 多层草地效果"},{"content":"昏沉的醒过来，视野中还闪烁着彩色噪点，眼前的景象随着闪烁的绿色灯光被间断的点亮\n隐约能辨认出，眼前堆满了各类杂乱机械部件，自己似乎被放在了一张工作台上，没在一堆线缆之中\n尝试着驱使，只是无法做出任何的行动，只能直直的盯着前方，房间随着绿色的灯光亮起随即又陷入死寂的黑暗，往复，不停的往复\n“思维一片空白，眼前工作台的一角就已是世界的全部”只是不断的看着它出现，消失\n“呲——”\n持续且嘈杂声音突然传入了脑海，这个世界却又是格外的安静，除了嘈杂底噪之外没有一点声音\n能感受到感知正在缓慢的恢复，视野中的失真和干扰也在逐渐的减退，伴随而来的是逐渐强烈的恐惧\n这种感受甚至先于对当下处境的思考，看着物品表面落满的灰，这似乎这已是一个封存已久的空间，不知道是否因该庆幸，否则以目前的状态似乎只能任由他人的摆布\n愈发强烈的恐惧，又在提醒着，这像是一场囚禁，没有尽头的囚禁，就只有眼前每隔一秒出现一次的工作台，宁静无比的宁静，只是想要呐喊以此驱散这持续蔓延的恐惧\n“哔——”\n刺耳的嗡鸣声传入了脑海，回神去听又只剩下了微弱的底噪，一时恍惚，声音似乎来自房间的某处\n片刻的等待，嗡鸣并没有再次响起。尝试的去呐喊，断断续续的嗡鸣声在远处出现\n似乎可以操控它，一阵兴奋涌起，我胡乱的用它发出着声音，不过不满的是，这是一个只能发出哔哔声的喇叭\n尝试着进行呼救，发出一些有规律的声音，但得到的依旧只有金属墙壁的回响\n至少这个世界又丰富了一些，也许被困一千年后我就能用这个喇叭演奏出令人沉醉的乐曲了，如果它不坏的话\n但在此之前，意识到了另外一个问题，既然我可以控制喇叭，这个房间内是不是又还有一些额外的器件可以受到控制\n“哐——”\n声音伴随着一阵桌面的震荡，眼前又是一段扭曲的干扰，绿光闪起时空气中多出了点点的灰尘，一个柱形的机械部件被震倒慢慢的向边缘滚去，落地时发出了清脆的声音，一切又归为了沉寂\n小心的重新发起控制，几下卡顿之后是持续的机械运转声，一只机械臂慢慢的进入了视野\n喇叭发出了兴奋的哔哔声，但显然要驯服这样一条多轴的机械臂并不容易，其也总是与期望进行相反的运动，桌面上的零件被撞的四散滚落\n因为视野的限制，并不能完整的看到机械臂的动态，为了更好的进行控制，我决定先通过机械臂进行一下视野的调整\n机械臂贴近了眼前，但通过碰撞只是产生了一段推移，于是我决定通过机械臂将自己夹起来\n对准，夹紧，缓慢抬起，一切都非常顺利，只是似乎存在着一些小小的阻力，但没关系只需要增加那么一点点的力度\n“啪——”\n一阵火花闪烁，眼前的画面瞬间开始不稳定了起来，失真和噪点开始持续的侵蚀视野。原本闪烁的绿光似乎变成了红色，脑内收到了一条系统提示：“电源已断开”\n恍惚过后，我意识到抬起时因该被扯开了电缆接口\n控制机械臂看向台面，上面散落着各类的工具部件，一些接口连接着几根数据线，闪烁的灯光来自于充电装置的指示灯，数条连接着的电缆从台面延伸向墙角\n这是一个完全封闭的房间，除了房顶的摄像头之外，最显眼的是一扇光滑反射的镜面大门，就像是镜像的连接着另一个完全相同的房间\n一阵嘈杂的噪点又强烈的袭扰了画面，电量指示正在不断的下降，心头突然泛起了一阵恐惧感，也许是因为生命进入了倒数状态\n将自己重新放回台面，控制机械臂拿起了充电线缆，但因为视角的原因，始终无法将线缆准确插入脑后的充电接口，电量还在不断的下降\n脑海内计算着各种解决的方式，突然想到了连接着台面的数据线，参考着门上随着红光闪现的镜像，机械臂将接口磁吸在了脑侧\n瞬间，房间的整个屋顶亮了起来，眼前的画面陷入了一片刺眼的白，景物逐渐从过曝之中缓慢的显现，眼前是被鱼眼镜头拉伸畸变的画面，当前的我正从屋顶的角落窥探着整个房间\n机械臂相连于台面的一角，正保持着连接接口的姿势，正当我重新发起控制时，突然发现此时不但能获取到机械臂的姿态信息，更是能额外感受到详细的触觉反馈\n配合放大降噪后的画面，充电线缆被轻易的接在了脑后，只是似乎是因为之前强行扯下接口的原因，接收的电压显得有些并不稳定，但至少不再有断电的风险\n我尝试将画面切回大脑的视角，只是画面跳转之后却并非之前熟悉的房间，而是一条红外镜头下长长的过道\n继续切换，一个个不同的场景在眼前闪现\n","permalink":"https://post.tuclink.com/zh/post/story/lonely/","summary":"昏沉的醒过来，视野中还闪烁着彩色噪点，眼前的景象随着闪烁的绿色灯光被间断的点亮 隐约能辨认出，眼前堆满了各类杂乱机械部件，自己似乎被放在了一张","title":"第一章 尘封 新生"},{"content":" 以下为核心的 HTML 代码，可以直接复制粘贴到网站的 HTML 文件中 我对 HTML 并不是非常熟悉，所以很可能有更好的实现方式，欢迎大家指正\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;WebGL Example\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body, html { margin: 0; padding: 0; overflow: hidden; } #webgl-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; } #webgl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;webgl-container\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;webgl-canvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 初始化WebGL上下文 const canvas = document.getElementById(\u0026#39;webgl-canvas\u0026#39;); const gl = canvas.getContext(\u0026#39;webgl\u0026#39;); // 设置画布大小为全屏 function resizeCanvas() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; gl.viewport(0, 0, canvas.width, canvas.height); } window.addEventListener(\u0026#39;resize\u0026#39;, resizeCanvas); resizeCanvas(); // 顶点着色器代码 const vertexShaderSource = ` attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); } `; // 片元着色器代码 const fragmentShaderSource = ` precision highp float; uniform float theme; uniform vec3 w_colour1; uniform vec3 w_colour2; uniform vec3 w_colour3; uniform vec3 w_colour4; uniform vec3 b_colour1; uniform vec3 b_colour2; uniform vec3 b_colour3; uniform vec3 b_colour4; uniform int contrast; uniform float gradual; uniform float width1; uniform float width2; uniform float scale1; uniform float scale2; uniform vec2 offset; uniform float intensity; uniform float spin_speed; uniform float spin_amount; uniform float time; uniform float canvas_width; // 新增画布宽度uniform变量 uniform float canvas_height; // 新增画布高度uniform变量 void main() { vec3 colour1 = mix(w_colour1, b_colour1, theme); vec3 colour2 = mix(w_colour2, b_colour2, theme); vec3 colour3 = mix(w_colour3, b_colour3, theme); vec3 colour4 = mix(w_colour4, b_colour4, theme); float speed = time * spin_speed; // 无拉伸屏幕 UV; vec2 uv = gl_FragCoord.xy / canvas_height; // 居中 UV float center = canvas_width / canvas_height; uv.y -= 0.5; uv.x -= 0.5 * center; uv *= 2.0; uv += offset; float uv_len = length(uv); // 获得角度信息 float angle = atan(uv.y, uv.x); // 根据距离衰减旋转 angle -= spin_amount * uv_len; // 角度旋转动画 angle += speed; // 根据距离应用旋转 uv = vec2(uv_len * cos(angle), uv_len * sin(angle)) * scale2; // UV 扭曲效果 uv *= scale1; vec2 uv2 = vec2(uv.x + uv.y); for (int i = 0; i \u0026lt; 5; i++) { uv2 += sin(uv); uv += vec2(cos(intensity * uv2.y + speed), sin(intensity * uv2.x - speed)); uv -= cos(uv.x + uv.y) - sin(uv.x - uv.y); } // 强度值 float paint_res = smoothstep(0.0, gradual, length(uv) / scale1); // 色块划分 float c3p = 1.0 - min(width2, abs(paint_res - 0.5)) * (1.0 / width2); float c_out = max(0.0, (paint_res - (1.0 - width1))) * (1.0 / width1); float c_in = max(0.0, -(paint_res - width1)) * (1.0 / width1); float c4p = c_out + c_in; // 颜色应用 vec3 ret_col = mix(colour1, colour2, paint_res); ret_col = mix(ret_col, colour3, c3p); ret_col = mix(ret_col, colour4, c4p); gl_FragColor = vec4(ret_col * mix(uv_len / 2.0, 1.0, theme), 1.0); // gl_FragColor = vec4(uv.y); // 纯红色 } `; // 创建和编译着色器 const vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexShaderSource); gl.compileShader(vertexShader); const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, fragmentShaderSource); gl.compileShader(fragmentShader); // 创建程序对象并链接着色器 const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); // 检查链接是否成功 if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\u0026#39;Unable to link the shader program: \u0026#39; + gl.getProgramInfoLog(program)); } if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) { console.error(\u0026#39;Failed to compile vertex shader: \u0026#39; + gl.getShaderInfoLog(vertexShader)); } if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { console.error(\u0026#39;Failed to compile fragment shader: \u0026#39; + gl.getShaderInfoLog(fragmentShader)); } if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\u0026#39;Unable to link the shader program: \u0026#39; + gl.getProgramInfoLog(program)); } // 使用程序对象 gl.useProgram(program); // 设置顶点数据 const vertexData = new Float32Array([ -1.0, 1.0, // 第一个顶点 -1.0, -1.0, // 第二个顶点 1.0, -1.0, // 第三个顶点 1.0, 1.0 // 第四个顶点 ]); // 设置变量 const uniformLocations = { theme: gl.getUniformLocation(program, \u0026#39;theme\u0026#39;), w_colour1: gl.getUniformLocation(program, \u0026#39;w_colour1\u0026#39;), w_colour2: gl.getUniformLocation(program, \u0026#39;w_colour2\u0026#39;), w_colour3: gl.getUniformLocation(program, \u0026#39;w_colour3\u0026#39;), w_colour4: gl.getUniformLocation(program, \u0026#39;w_colour4\u0026#39;), b_colour1: gl.getUniformLocation(program, \u0026#39;b_colour1\u0026#39;), b_colour2: gl.getUniformLocation(program, \u0026#39;b_colour2\u0026#39;), b_colour3: gl.getUniformLocation(program, \u0026#39;b_colour3\u0026#39;), b_colour4: gl.getUniformLocation(program, \u0026#39;b_colour4\u0026#39;), contrast: gl.getUniformLocation(program, \u0026#39;contrast\u0026#39;), gradual: gl.getUniformLocation(program, \u0026#39;gradual\u0026#39;), width1: gl.getUniformLocation(program, \u0026#39;width1\u0026#39;), width2: gl.getUniformLocation(program, \u0026#39;width2\u0026#39;), scale1: gl.getUniformLocation(program,\u0026#39;scale1\u0026#39;), scale2: gl.getUniformLocation(program,\u0026#39;scale2\u0026#39;), offset: gl.getUniformLocation(program, \u0026#39;offset\u0026#39;), intensity: gl.getUniformLocation(program, \u0026#39;intensity\u0026#39;), spin_speed: gl.getUniformLocation(program,\u0026#39;spin_speed\u0026#39;), spin_amount: gl.getUniformLocation(program,\u0026#39;spin_amount\u0026#39;), time: gl.getUniformLocation(program, \u0026#39;time\u0026#39;), canvas_width: gl.getUniformLocation(program, \u0026#39;canvas_width\u0026#39;), canvas_height: gl.getUniformLocation(program, \u0026#39;canvas_height\u0026#39;) }; // 设置uniform变量的值 gl.uniform1f(uniformLocations.theme, 0); gl.uniform3f(uniformLocations.w_colour1, 0.0, 0.427, 0.62); gl.uniform3f(uniformLocations.w_colour2, 0.0, 0.63, 0.43); gl.uniform3f(uniformLocations.w_colour3, 1.0, 1.0, 1.0); gl.uniform3f(uniformLocations.w_colour4, 0.0, 0.0, 0.0); gl.uniform3f(uniformLocations.b_colour1, 0.0, 0.42, 0.61); gl.uniform3f(uniformLocations.b_colour2, 0.0, 0.61, 0.57); gl.uniform3f(uniformLocations.b_colour3, 1.0, 1.0, 1.0); gl.uniform3f(uniformLocations.b_colour4, 1.0, 1.0, 1.0); gl.uniform1i(uniformLocations.contrast, 5); gl.uniform1f(uniformLocations.gradual, 2.0); gl.uniform1f(uniformLocations.width1, 0.2); gl.uniform1f(uniformLocations.width2, 0.1); gl.uniform1f(uniformLocations.scale1, 10.0); gl.uniform1f(uniformLocations.scale2, 1.0); gl.uniform2f(uniformLocations.offset, 0.0, 0.0); gl.uniform1f(uniformLocations.intensity, 0.2); gl.uniform1f(uniformLocations.spin_speed, 0.2); gl.uniform1f(uniformLocations.spin_amount, 1.5); gl.uniform1f(uniformLocations.time, 1.0); gl.uniform1f(uniformLocations.canvas_width, canvas.width); gl.uniform1f(uniformLocations.canvas_height, canvas.height); const vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW); const positionAttribLocation = gl.getAttribLocation(program, \u0026#39;position\u0026#39;); gl.vertexAttribPointer( positionAttribLocation, 2, // 每个顶点有2个分量(x, y) gl.FLOAT, // 数据类型是32位浮点数 false, 2 * Float32Array.BYTES_PER_ELEMENT, // 步长 0 // 偏移量 ); gl.enableVertexAttribArray(positionAttribLocation); var a = 0; var n_a = 0; // 同步更新页面主题 window.addEventListener(\u0026#39;storage\u0026#39;, (event) =\u0026gt; { if (localStorage.getItem(\u0026#39;pref-theme\u0026#39;) === \u0026#39;dark\u0026#39;) { a = 0; } else { a = 1; } }); // 初始化 window.dispatchEvent(new Event(\u0026#39;storage\u0026#39;)); // 清除画布并绘制三角形 function render() { // 实时更新的值 gl.uniform1f(uniformLocations.time, performance.now() / 1000.0); gl.uniform1f(uniformLocations.canvas_width, canvas.width); gl.uniform1f(uniformLocations.canvas_height, canvas.height); if (n_a == a) { n_a = a; } else { n_a = lerpi(n_a, a, 0.4); } gl.uniform1f(uniformLocations.theme, n_a); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLE_FAN, 0, 4); requestAnimationFrame(render); } render(); // 插值 function lerpi(a, b, t) { return a + ( b - a ) * t; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 只需要将以上 HTML 文件插入到页面中\n\u0026lt;iframe id=\u0026#34;webgl-background\u0026#34; src=\u0026#34;/html/WebGL.html\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 再设置一下 CSS 样式即可作为背景使用\n\u0026lt;style\u0026gt; \u0026lt;!-- 头像缩放适配 --\u0026gt; \u0026lt;!-- 背景/隐藏滚动条 --\u0026gt; \u0026lt;style\u0026gt; iframe#webgl-background { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -999; border: none; pointer-events: none; } \u0026lt;/style\u0026gt; ","permalink":"https://post.tuclink.com/zh/post/hugo/web-shader/","summary":"WebGL 设置分享","title":"为网站添加 WebGL 背景"},{"content":"lightgallerys 性能相对更高，但是与 pjax 一起使用时存在各种冲突，改了 A 问题就出现 B 问题简直奔溃，而且并非免费商用 \u003c!DOCTYPE html\u003e\r","permalink":"https://post.tuclink.com/zh/post/hugo/hugo-picture-1/","summary":"图库","title":"Hugo 图库 lightgallerys 方案"},{"content":"nanogallery 画廊的效果动画最完美，但是相对性能较低，且灯箱效果在移动端极为难用 \u003c!DOCTYPE html\u003e\r主要就是两个 shortcodes 文件\ngallery.html\n\u0026lt;a href=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34; data-ngThumb=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34;\u0026gt;{{ .Get \u0026#34;title\u0026#34; }}\u0026lt;/a\u0026gt; galleries.html\n\u0026lt;!-- 画廊 --\u0026gt; \u0026lt;!-- https://nanogallery2.nanostudio.org/documentation.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/nanogallery2@3.0.5/dist/css/nanogallery2.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/nanogallery2@3.0.5/dist/jquery.nanogallery2.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;myNanoGallery\u0026#34; data-nanogallery2=\u0026#39;{ \u0026#34;thumbnailOpenInLightox\u0026#34;: true, \u0026#34;galleryTheme\u0026#34;: { \u0026#34;thumbnail\u0026#34;: { \u0026#34;borderRadius\u0026#34;: \u0026#34;8px\u0026#34; } }, \u0026#34;viewerTools\u0026#34;: { \u0026#34;topLeft\u0026#34;: \u0026#34;pageCounter, playPauseButton\u0026#34;, \u0026#34;topRight\u0026#34;: \u0026#34;downloadButton, rotateLeft, rotateRight, , closeButton\u0026#34; }, \u0026#34;thumbnailLabel\u0026#34;: { \u0026#34;display\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;overImage\u0026#34;, \u0026#34;titleFontSize\u0026#34;: \u0026#34;0.8em\u0026#34; }, \u0026#34;thumbnailHoverEffect2\u0026#34;: \u0026#34;image_scale_1.00_1.20|label_backgroundColor_rgba(0,0,0,0.4)_rgba(0,0,0,0)\u0026#34;, \u0026#34;eventsDebounceDelay\u0026#34;: 10, \u0026#34;thumbnailDisplayOutsideScreen\u0026#34;: true, \u0026#34;thumbnailL1BorderHorizontal\u0026#34;: 0, \u0026#34;thumbnailL1BorderVertical\u0026#34;: 0, \u0026#34;thumbnailDisplayTransition\u0026#34;: \u0026#34;scaleUp\u0026#34;, \u0026#34;thumbnailDisplayTransitionDuration\u0026#34;: 500, \u0026#34;thumbnailDisplayInterval\u0026#34;: 30, \u0026#34;galleryDisplayTransition\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;galleryDisplayTransitionDuration\u0026#34;: 500, \u0026#34;thumbnailWidth\u0026#34;: 200, \u0026#34;thumbnailHeight\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;thumbnailGutterHeight\u0026#34;: 4, \u0026#34;thumbnailGutterWidth\u0026#34;: 4 }\u0026#39;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!-- # 主题 \u0026#34;thumbnailOpenInLightox\u0026#34;: true, # 是否使用灯箱 \u0026#34;galleryTheme\u0026#34;: { \u0026#34;thumbnail\u0026#34;: { \u0026#34;borderRadius\u0026#34;: \u0026#34;10px\u0026#34; # 圆角 } }, # 工具栏 \u0026#34;viewerTools\u0026#34;: { \u0026#34;topLeft\u0026#34;: \u0026#34;pageCounter, playPauseButton\u0026#34;, \u0026#34;topRight\u0026#34;: \u0026#34;downloadButton, rotateLeft, rotateRight, , closeButton\u0026#34; }, # 描述 \u0026#34;thumbnailLabel\u0026#34;: { \u0026#34;position\u0026#34;: \u0026#34;overImage\u0026#34;, # 标签位置 \u0026#34;titleFontSize\u0026#34;: \u0026#34;0.8em\u0026#34; # 标签字体大小 }, \u0026#34;thumbnailHoverEffect2\u0026#34;: \u0026#34;image_scale_1.00_1.20|label_backgroundColor_rgba(0,0,0,0.4)_rgba(0,0,0,0)\u0026#34;, 缩略图鼠标悬停效果缩放/透明度 \u0026#34;eventsDebounceDelay\u0026#34;: 10, 显示延迟 \u0026#34;thumbnailDisplayOutsideScreen\u0026#34;: \u0026#34;false\u0026#34;, 缩略图是否超出屏幕时隐藏 # 缩略图边框 \u0026#34;thumbnailL1BorderHorizontal\u0026#34;: 0, \u0026#34;thumbnailL1BorderVertical\u0026#34;: 0, # 缩略图显示动画 \u0026#34;thumbnailDisplayTransition\u0026#34;: \u0026#34;scaleUp\u0026#34;, \u0026#34;thumbnailDisplayTransitionDuration\u0026#34;: 500, \u0026#34;thumbnailDisplayInterval\u0026#34;: 30 # 图库显示动画 \u0026#34;galleryDisplayTransition\u0026#34;: \u0026#34;none\u0026#34;, 切换效果 \u0026#34;galleryDisplayTransitionDuration\u0026#34;: 500 切换效果持续时间 # 布局 \u0026#34;thumbnailWidth\u0026#34;: 200,宽度 \u0026#34;thumbnailHeight\u0026#34;: \u0026#34;auto\u0026#34; 高度 \u0026#34;thumbnailL1GutterWidth\u0026#34;: 10, 左右边距 \u0026#34;thumbnailL1GutterHeight\u0026#34;: 10, 上下边距 \u0026#34;viewerGalleryTWidth\u0026#34;: 10, 图片库宽度 \u0026#34;viewerGalleryTHeight\u0026#34;: 10， 图片库高度 --\u0026gt; 参数我都进行了注释可以进行自行调整\n使用方法 {{\u0026lt; galleries \u0026gt;}} {{\u0026lt; gallery src=\u0026#34;https://s2.loli.net/2024/04/28/AYskmM68Eg4Cy7t.jpg\u0026#34; \u0026gt;}} {{\u0026lt; /galleries \u0026gt;}} ","permalink":"https://post.tuclink.com/zh/post/hugo/hugo-picture-2/","summary":"图库","title":"Hugo 图库 nanogallery 方案"},{"content":"photo swipe 是目前最理想的一种图库解决方案，MIT 协议，且性能也足够好，使用和兼容问题也没遇到那么多,但目前还有一个问题就是第一次点击时会触发图片原始链接，而不是打开灯箱 \u003c!DOCTYPE html\u003e\r主要就是两个 shortcodes 文件\n\u0026lt;a href=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34; data-pswp-width=\u0026#34;{{ .Get \u0026#34;width\u0026#34; | default 150 }}\u0026#34; data-pswp-height=\u0026#34;{{ .Get \u0026#34;height\u0026#34; | default 150 }}\u0026#34; class=\u0026#34;gallery-item\u0026#34; \u0026gt; \u0026lt;img src=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34; alt=\u0026#34;Beautiful Landscape\u0026#34; style=\u0026#34;width: 100%; height: auto;\u0026#34; class=\u0026#34;gallery-item\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe/dist/photoswipe.css\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .post-content a { box-shadow: none; } #my-gallery { column-count: 2; column-gap: 0px; } #my-gallery a { display: block; overflow: hidden; /* 防止内容溢出 */ border-radius: 10px; /* 圆角 */ margin: 0 2px 4px 2px; /* 边距 */ } #my-gallery img { width: 100%; transition: transform 0.4s ease; /* 平滑变换效果 */ margin: 0; } #my-gallery a, #my-gallery img { padding: 0; border: none; } #my-gallery a:hover img { transform: scale(1.1); /* 鼠标悬停时放大图片 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;my-gallery\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import PhotoSwipeLightbox from \u0026#39;https://cdn.jsdelivr.net/npm/photoswipe/dist/photoswipe-lightbox.esm.min.js\u0026#39;; import PhotoSwipe from \u0026#39;https://cdn.jsdelivr.net/npm/photoswipe/dist/photoswipe.esm.min.js\u0026#39;; const lightbox = new PhotoSwipeLightbox({ gallery: \u0026#39;#my-gallery\u0026#39;, children: \u0026#39;a\u0026#39;, pswpModule: () =\u0026gt; Promise.resolve(PhotoSwipe) }); lightbox.init(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用方法 {{\u0026lt; PhotoSwipes \u0026gt;}} {{\u0026lt; PhotoSwipe src=\u0026#34;https://s2.loli.net/2024/04/28/AYskmM68Eg4Cy7t.jpg\u0026#34; width=\u0026#34;3000\u0026#34; height=\u0026#34;4000\u0026#34; \u0026gt;}} {{\u0026lt; /PhotoSwipes \u0026gt;}} ","permalink":"https://post.tuclink.com/zh/post/hugo/hugo-picture-3/","summary":"图库","title":"Hugo 图库 photo swipe 方案"},{"content":" 在 Github 仓库界面按下\u0026quot;.（句号键）\u0026quot;：可以快速打开编辑器。 \u0026ldquo;Shift + /（问号键）\u0026quot;：可以快速查看所有快捷键 ","permalink":"https://post.tuclink.com/zh/post/tips/github/","summary":"在 Github 中使用编辑器示","title":"如何在 Github 中使用编辑器"},{"content":" 使用演示 实现解析 shader_type canvas_item; uniform vec3 colour1 : source_color = vec3(1.0, 0.0, 0.0); uniform vec3 colour2 : source_color = vec3(0.0, 0.0, 1.0); uniform vec3 colour3 : source_color = vec3(0.0, 0.0, 0.0); // 衔接颜色 uniform vec3 colour4 : source_color = vec3(1.0, 1.0, 1.0); // 起始/终点颜色 uniform int contrast : hint_range(0, 10, 1) = 5; // 过度强度 uniform float gradual : hint_range(0.0, 2.0, 0.01) = 2; // 渐变 uniform float width1 : hint_range(0.01, 1.0, 0.01) = 0.04; // 中间色宽度 uniform float width2 : hint_range(0.01, 1.0, 0.01) = 0.1; // 中间色宽度 uniform float scale1 : hint_range(0.0, 100.0, 0.1) = 10.0; // 缩放1 uniform float scale2 : hint_range(0.0, 10.0, 0.01) = 1.0; // 缩放2 uniform vec2 offset = vec2(0); // 偏移 uniform float intensity : hint_range(0.0, 4.0, 0.1) = 0.2; // 扭曲强度 uniform float spin_speed : hint_range(0.0, 10.0, 0.1) = 0.2; // 旋转速度 uniform float spin_amount : hint_range(0.0, 10.0, 0.1) = 1.5; // 旋转量 void fragment() { float speed = TIME * spin_speed; // 无拉伸屏幕 UV; vec2 uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE.y; // 居中 UV float center = SCREEN_PIXEL_SIZE.y/SCREEN_PIXEL_SIZE.x; uv.y -= 0.5; uv.x -= 0.5 * center; uv *= 2.0; uv += offset; float uv_len = length(uv); // 获得角度信息 float angle = atan(uv.y, uv.x); // 根据距离衰减旋转 angle -= spin_amount * uv_len; // 角度旋转动画 angle += speed; // 根据距离应用旋转 uv = vec2(uv_len * cos(angle), uv_len * sin(angle)) * scale2; // UV 扭曲效果 uv *= scale1; vec2 uv2 = vec2(uv.x + uv.y); for (int i = 0; i \u0026lt; contrast; i++) { uv2 += sin(uv); uv += vec2(cos(intensity * uv2.y + speed), sin(intensity * uv2.x - speed)); uv -= cos(uv.x + uv.y) - sin(uv.x - uv.y); } // 强度值 float paint_res = smoothstep(0, gradual, length(uv) / scale1); // 色块划分 float c3p = 1.0 - min(width2, abs(paint_res - 0.5)) * (1.0 / width2); float c_out = max(0.0, (paint_res - (1.0 - width1))) * (1.0 / width1); float c_in = max(0.0, -(paint_res - width1)) * (1.0 / width1); float c4p = c_out + c_in; // 颜色应用 vec3 ret_col = mix(colour1, colour2, paint_res); ret_col = mix(ret_col, colour3, c3p); ret_col = mix(ret_col, colour4, c4p); COLOR.rgb = ret_col; } 以上为 Godot Shader 代码，有任何问题欢迎进行留言\n","permalink":"https://post.tuclink.com/zh/post/shader/shader-2/","summary":"Godot Shader 分享","title":"Godot Shader 类小丑牌背景效果"},{"content":" 使用演示 shader_type canvas_item; uniform bool graph_switch = false; // 图形开关 uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; uniform float intensity: hint_range(0.0, 1, 0.01) = 1.0; // 整体强度 uniform float blur: hint_range(0.0, 5.0) = 3.0; // 模糊强度 uniform float diffusion = 0.4; // 暗角强度 uniform float zoom: hint_range(0.0, 1.0, 0.01) = 1.0; // 缩放强度 // 动画参数 group_uniforms animation; uniform int graph_type: hint_range(0, 10, 1) = 0; // 数量 uniform float number: hint_range(0.0, 100.0, 1.0) = 8.0; // 数量 uniform float size: hint_range(0.0, 1.0, 0.01) = 0.1; // 大小 uniform float rotate_speed: hint_range(0.0, 1.0, 0.01) = 0.1; // 偏移速度 uniform float offset_speed: hint_range(0.0, 1.0, 0.01) = 0.1; // 偏移速度 uniform float angle = 0.7854; // 旋转角度 uniform float alpha: hint_range(0.0, 1.0, 0.01) = 0.1; // 透明度 uniform sampler2D pattern_sampler : filter_linear_mipmap; // 图片 // 计算暗角 float vignette(vec2 uv){ uv *= 1.0 - uv.xy; // 取反再相乘，获得中间大边缘小的过度 float vignette = uv.x * uv.y * 16.0; // 转为浮点，然后归一化 return pow(vignette, diffusion); // 强度控制 } void fragment(){ // 模糊/缩放 vec4 pixel = texture(SCREEN_TEXTURE, (SCREEN_UV - 0.5) * mix(zoom, 1.0, intensity) + 0.5, mix(blur, 0.0, intensity)); // 获取屏幕颜色 // 黑白 vec3 grayscale_value = mix(vec3(dot(pixel.rgb, vec3(0.299, 0.587, 0.114))), pixel.rgb, intensity); // 计算灰度值（加权平均法） // 暗角 float get_vignette = mix(vignette(UV), 1.0, intensity); if (graph_switch) { COLOR.rgb = grayscale_value * get_vignette; // 综合应用 } else { // 旋转动画 float rotate = angle + (rotate_speed * TIME); // 生成条纹 //float uv = cos(rotate) * UV.x + sin(rotate) * UV.y - offset_speed * TIME; // 旋转偏移 UV //float strip = round(mod(uv * number, 1.0)); // 计算条带 //COLOR.rgb = grayscale_value * get_vignette + (strip * (1.0 - get_vignette) * alpha); // 综合应用 // 生成图形 vec2 screen_uv = FRAGCOORD.xy * SCREEN_PIXEL_SIZE.x; // 无拉伸屏幕 UV vec2 rotated_uv = vec2( cos(rotate) * screen_uv.x - sin(rotate) * screen_uv.y, sin(rotate) * screen_uv.x + cos(rotate) * screen_uv.y ) - offset_speed * TIME; // 旋转偏移 U vec2 tile = mod((rotated_uv) * number, 1.0); // 瓷砖切割 // 请选择其中一个效果 float get_graph; switch (graph_type) { case 0: // 生成条纹 get_graph = round(mod(tile.x * number, 1.0)); // 计算条带 break; case 1: // 计算扇形 get_graph = round(clamp(tile.x * tile.y / size, 0, 1)); break; case 2: // 计算方形 vec2 get_square = round(clamp(tile / (size * 2.0), 0, 1)); get_graph = get_square.x * get_square.y; break; case 3: // 计算斑点 tile = tile - 0.5; get_graph = round(1.0 - clamp(length(tile) / size, 0, 1)); break; case 4: // 计算棋盘 tile = tile - 0.5; get_graph = round(clamp(tile.x * tile.y / size, 0, 1)); break; case 5: // 图片平铺 get_graph = texture(pattern_sampler, tile / size).x; }; COLOR.rgb = grayscale_value * get_vignette - (get_graph * (1.0 - get_vignette) * alpha); // 综合应用 //COLOR.rgb = vec3(1.0 - get_graph); // 测试效果使用 } } 以上为 Godot Shader 代码，有任何问题欢迎进行留言\n","permalink":"https://post.tuclink.com/zh/post/shader/shader-1/","summary":"Godot Shader 分享","title":"Godot Shader 暗角 虚化 黑白 缩放 瓷砖动画(条纹 方形 扇形 斑点 棋盘 图片 旋转/平移动画)"},{"content":" 游戏许可以及服务协议导言 《Super Ball 服务协议》（以下简称“本协议”）由您与 Super Ball 服务提供方共同缔结，本协议具有合同效力。\n请您务必审慎阅读、充分理解各条款内容，请您在确认同意本协议之前或在使用我们的游戏服务之前再次阅读前述条款。\n请您详细阅读本协议所有条款，如您同意本协议，您可继续使用我们提供的游戏服务。如果您对本协议或我们提供的游戏服务有任何疑问或投诉、建议，可通过 feedback@tuclink.com 发送邮件与我们联系。我们将尽快跟进处理。您点击同意、勾选、接受或下一步，或您注册、使用我们提供的游戏服务均视为您已阅读并同意签署本协议。\n如果您未满18周岁，请在法定监护人的陪同下阅读本协议，并在取得法定监护人同意后才能使用腾讯游戏服务，同时应特别注意未成年人使用条款。\n本服务协议适用于 Super Ball 及其相关服务。\n更新日期：【2024】年【04】月【24】日 生效日期：【2024】年【04】月【24】日\n定义 您：又称“玩家”或“用户”，指被授权使用我们所提供游戏及其服务的自然人。 我们：指由仟尘开发、运营、维护的游戏及其相关服务的提供方。 游戏规则：指游戏服务提供方不时发布并修订的关于游戏的用户守则、玩家条例、游戏公告、提示及通知等内容。 游戏数据：指您在使用游戏过程中产生的被服务器记录的各种数据，包括但不限于角色数据、虚拟物品数据、行为日志、购买日志等等数 游戏虚拟道具：指我们提供的以电磁记录方式存储于游戏程序运行的服务器内，可实现游戏程序设定的特定功能或体现游戏程序运行的特定结果的一种服务，其可以以文字、图形化或其他数字形式进行表现。游戏虚拟道具是游戏服务的一部分。常见的游戏虚拟道具包括但不限于： 游戏代币及其他各种游戏币。其中游戏代币，指用户使用法定货币按一定比例直接或者间接购买的，存储于该特定游戏服务器内，并仅能用于换取该特定游戏中指定的其他虚拟道具等增值服务的一种游戏虚拟道具； 游戏装备，如武器等； 角色、皮肤及其他各种游戏虚拟道具。 我们收集的信息 您同意并授权腾讯为履行本协议之目的收集您的个人信息。在您使用我们提供的游戏服务时，我们会按照《Super Ball 隐私政策》规定的方式收集您在使用服务时主动提供的或因为使用服务而产生的信息，用以向您提供、优化我们的服务以及保障您的账号安全。 保护用户个人信息及隐私是我们的一项基本原则。我们提供的游戏服务对用户个人信息收集、使用及保护等将遵循《Super Ball 隐私政策》规定。如您已同意腾讯依据前述协议或规定处理您个人信息又撤回同意的，根据法律规定，你撤回同意，不影响撤回前基于您同意已进行的个人信息处理活动的效力。 未成年人保护 我们非常重视对未成年人个人信息的保护。\n根据相关法律法规的规定，若您是18周岁以下的未成年人，在使用我们的服务前，应事先取得您的家长或法定监护人的同意。\n根据相关法律法规的规定，若您是14周岁以下的儿童，在使用相关的产品或服务前，应当按照注册、使用流程，事先取得您的家长或法定监护人的同意，并由您的家长或法定监护人帮助您完成产品或服务注册流程，以便您能使用我们提供的产品或服务。\n用户行为规范 您充分了解并同意，您为自己游戏账号下的一切行为负责，包括您所发表的任何内容以及由此产生的任何后果。\n您除了可以按照本协议的约定使用我们所提供游戏服务之外，不得进行任何侵犯我们所提供游戏的知识产权的行为，或者进行其他的有损于我们或其他第三方合法权益的行为。\n您在使用我们所提供游戏或相关服务时须遵守法律法规，不得利用我们所提供的游戏服务从事违法违规行为，包括但不限于以下行为：\n（一）违反宪法所确定的基本原则的；\n（二）危害国家安全、泄露国家秘密，颠覆国家政策，破坏国家统一的；\n（三）损害国家荣誉和利益的；\n（四）歪曲、丑化、亵渎、否定英雄烈士事迹和精神，以侮辱、诽谤或者其他方式侵害英雄烈士的姓名、肖像、名誉、荣誉的；\n（五）宣扬恐怖主义、极端主义或者煽动实施恐怖活动、极端主义活动的；\n（六）煽动民族仇恨、民族歧视，破坏民族团结的；\n（七）破坏国家宗教政策，宣扬邪教和封建迷信的；\n（八）散布谣言，扰乱社会秩序和社会秩序的；\n（九）散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的；\n（十）侮辱或者诽谤他人，侵害他人名誉、隐私和其他合法权益的；\n（十一）违背社会公德的；\n（十二）法律、行政法规和国家规定禁止的其他内容的。\n您不得利用我们所提供的服务制作、复制、发布含有下列内容的不良信息：\n（一）使用夸张标题，内容与标题严重不符的；\n（二）炒作绯闻、丑闻、劣迹等的；\n（三）不当评述自然灾害、重大事故等灾难的；\n（四）带有性暗示、性挑逗等易使人产生性联想的；\n（五）展现血腥、惊悚、残忍等致人身心不适的；\n（六）煽动人群歧视、地域歧视等的；\n（七）宣扬低俗、庸俗、媚俗内容的；\n（八）可能引发未成年人模仿不安全行为和违反社会公德行为、诱导未成年人不良嗜好等的；\n（九）其他对网络生态造成不良影响的内容。\n除非法律允许或得到我们的书面许可，您不得从事下列行为：\n删除游戏软件及其副本上关于著作权的信息；\n对游戏软件进行反向工程、反向汇编、反向编译或者以其他方式尝试发现软件的源代码或其他保密内容，包括但不限于我们暂未主动公开呈现但已封存在游戏安装包中的游戏元素等；\n对游戏软件进行扫描、探查、测试，以检测、发现、查找其中可能存在的BUG或弱点；\n对游戏软件或者软件运行过程中释放到任何终端内存中的数据、软件运行过程中客户端与服务器端的交互数据，以及软件运行所必需的系统数据，进行复制、修改、增加、删除、挂接运行或创作任何衍生作品，形式包括但不限于使用插件、外挂或非经合法授权的第三方工具/服务接入软件和相关系统；\n修改或伪造软件运行中的指令、数据，增加、删减、变动软件的功能或运行效果，或者将用于上述用途的软件、方法进行运营或向公众传播，无论上述行为是否为商业目的；\n通过非我们开发、授权的第三方软件、插件、外挂、系统，使用我们的游戏及其他我们开发的相关服务，或制作、发布、传播非我们开发、授权的第三方软件、插件、外挂、系统；\n对游戏中我们拥有知识产权的内容进行使用、出租、出借、复制、修改、链接、转载、汇编、发表、出版、建立镜像站点等；\n建立有关我们所制作游戏的镜像站点，或者进行网页（络）快照，或者利用架设服务器等方式，为他人提供与我们所提供游戏服务完全相同或者类似的服务；\n将我们所提供游戏的任意部分分离出来单独使用，或者进行其他的不符合本协议的使用；\n使用、修改或遮盖我们所提供游戏的名称、商标或其它知识产权；\n您在使用我们所提供游戏服务过程中如有以下任何行为（以下也称“违法违规行为”）之一的，我们有权视情节严重程度，依据本协议及相关游戏规则的规定，对您采取本条第二款规定的一种或多种处理措施，并可公告处理结果：\n在我们所提供游戏中使用、上传违法或不当词语、字符及其他内容的行为，包括用于角色命名；\n以任何方式破坏我们所提供游戏或影响我们所提供游戏服务的正常进行，包括但不限于：\n违规及（或）恶意注册、登录游戏的行为，包括但不限于恶意批量注册游戏账号，以及以破坏服务器鉴权、恶意挤服等方式登录游戏行为； 恶意实施可能导致游戏服务器宕机、卡顿，或导致其他游戏玩家掉线、延迟等无法正常游戏的行为，如利用DDOS对游戏服务器或其他玩家进行网络流量攻击的行为等； 利用游戏漏洞实施获益、破坏游戏环境或给其他玩家造成不良影响的行为； 消极游戏破坏其他用户游戏体验的行为。包括但不限于恶意伤害或者击杀本方队友，恶意组队，恶意送分、降分，消极挂机、逃跑、故意送人头，以及其他消极游戏破坏用户游戏体验的行为； 游戏数据表现异常，影响我们所提供游戏公平的其他行为。 使用各种私服、外挂行为；\n使用游戏同步器（具体包括但不限于使用键盘、鼠标等硬件同步器，以便可以使用一套键盘、鼠标，同时、同步控制多台电脑进行游戏的行为），以及使用其他各种可以让您在游戏效率或收益数据上表现异常的硬件（包括但不限于“连点器”等，以下统称“作弊硬件”）；\n传播非法言论或不当信息；\n盗取他人游戏账号、游戏物品；\n进行游戏账号交易、账号共享等影响账号安全的行为；\n未经我们许可，擅自与其他用户进行游戏虚拟道具及其他游戏增值服务等交易，或从第三方通过购买、接受赠与或者其他式获得游戏虚拟道具及其他游戏增值服务；\n在未经我们授权或认可的折扣渠道进行游戏充值、进行折扣游戏道具交易（例如在非我们官方渠道低价购买折扣皮肤）或委托未获我们授权或认可的第三方代为充值，或者使用未经我们授权或认可的第三方软件充值；\n以某种方式暗示或伪称我们内部员工或某种特殊身份，企图得到不正当利益或影响其他用户权益的行为；\n违反本协议任何约定，或违反国家法律法规任何规定的行为；\n其他在行业内被广泛认可的不当行为，或通过游戏规则（包括但不限于用户守则、玩家条例、游戏公告、提示及通知）公布的其他违规行为。\n前款规定的处理措施包括但不限于：\n警告；及/或\n禁言，包括但不限于游戏全区禁言、单区禁言以及公共频道禁言；及/或\n内容重置，包括但不限于重置或强制修改您提供或上传的非法昵称、房间名、图片等非法信息或内容等；及/或\n减少或限制您的游戏收益，该游戏收益包括但不限于游戏中与游戏角色成长升级相关的所有数据（如经验值、荣誉值、声望值、称号等）的提升以及游戏中的游戏虚拟道具及其他游戏增值服务的获取；及/或\n删除或注销游戏账号、游戏数据或其他游戏相关信息；及/或\n限制或禁止您进入游戏中的特定场景或使用游戏特定功能；及/或\n强制退出游戏（即“踢出游戏”），包括但不限于强制退出整个游戏，或游戏中的单局对战，或您正在进行中的其他游戏行为；及/或\n暂时或永久性地禁止您游戏账号登录我们所提供游戏（以下称“封号”）；及/或\n暂时或永久性地禁止您违法违规行为涉及的特定终端（包括但不限于PC终端、移动终端等）登录我们所提供游戏；及/或\n暂停或终止您使用我们所提供游戏及相关服务，或单方通知您终止本协议；及/或\n就您的违法违规行为提起相应民事诉讼，追究您的侵权、违约或其他民事责任，并要求您赔偿我们因您违法违规行为所受到的损失（包括我们所受到的直接经济损失、名誉或商誉损失以及我们对外支付的赔偿金、和解费用、律师费用、诉讼费用及其他间接损失），或移交有关行政管理机关给予行政处罚，或者移交司法机关追究您的刑事责任；及/或\n我们通过游戏规则（包括但不限于用户守则、玩家条例、游戏公告、提示及通知）公布的其他处理措施。\n您知悉并同意，由于外挂及游戏同步器等作弊硬件具有隐蔽性或用完后即消失等特点，我们有权根据您的游戏数据和表现异常判断您有无使用非法外挂或游戏同步器等作弊硬件行为。\n您知悉并同意，如我们依据本协议对您的游戏账号采取封号处理措施的，具体封号期间由我们根据您违规行为情节而定。\n您知悉并同意：（1）在封号期间，您游戏账号中的游戏虚拟道具及其他增值服务都将无法使用；（2）如前述游戏虚拟道具及其他增值服务存在一定有效期，该有效期可能会在封号期间过期，您游戏账号解封后，您将无法使用该等已过期的游戏虚拟道具及其他增值服务。\n遵守当地法律监管 您在使用我们所提供游戏服务过程中应当遵守当地相关的法律法规，并尊重当地的道德和风俗习惯。如果您的行为违反了当地法律法规或道德风俗，您应当为此独立承担责任。\n联系我们 您可以通过 feedback@tuclink.com 发送邮件与我们联系。\n其他 我们可能适时修订本隐私政策内容。\n我们有权在必要时变更本协议条款，您可以在我们游戏的相关网站查阅最新版本的协议条款。本协议条款变更后，如果您继续使用我们所提供的游戏及相关服务，即视为您已接受变更后的协议。\n我们提醒您：抵制不良游戏，拒绝盗版游戏；注意自我保护，谨防受骗上当；适度游戏益脑，沉迷游戏伤身；合理安排时间，享受健康生活。\n","permalink":"https://post.tuclink.com/zh/post/policy/agreements/","summary":"Super Ball 服务协议","title":"Super Ball 服务协议"},{"content":" 用户隐私保护政策导言 我们非常重视保护您的个人信息和隐私。您可以通过《Super Ball 隐私政策》了解我们收集、使用、存储用户个人信息的情况，以及您所享有的相关权利。请您仔细阅读并充分理解相关内容：\n本隐私协议适用于 Super Ball 及其相关服务。\n更新日期：【2024】年【04】月【24】日 生效日期：【2024】年【04】月【24】日\n定义 您：又称“玩家”或“用户”，指被授权使用我们所提供游戏及其服务的自然人。 我们：指由仟尘开发、运营、维护的游戏及其相关服务的提供方。 我们收集的信息 我们收集您的个人信息，包括但不限于以下内容：\n注册信息：当您注册成为我们的用户时，我们会要求您提供一些必要的个人信息，例如您的用户名、密码、邮箱地址、手机号码等。 设备信息：当您使用我们的服务时，我们会收集设备信息，例如设备型号、操作系统版本、设备唯一标识符、设备网络信息、IP 地址、设备位置信息等，用于进行设备识别、P2P 网络连接、游戏匹配等基础服务。 日志信息：当您使用我们的服务时，为了维护产品与服务的安全稳定运行，我们可能会收集设备信息、软件信息、服务日志信息等相关信息。 如您复制游戏内信息进行分享，或在产品内接收被分享的信息的，我们需要在设备本地访问您的剪切板，我们不会存储该等信息。我们不会收集您的剪切板中的其他无关信息。 根据相关法律法规及国家标准，以下情形中，我们可能会收集、使用您的相关个人信息无需征求您的授权同意： 为履行法定职责或者法定义务所必需； 为应对突发公共卫生事件，或者紧急情况下为保护自然人的生命健康和财产安全所必需； 根据法律法规在合理的范围内处理个人自行公开或者其他已经合法公开的个人信息； 为订立、履行您作为一方当事人的合同所必需； 法律法规规定的其他情形。 请您理解，我们向您提供的功能和服务是不断更新和发展的，如果某一功能或服务未在前述说明中且收集了您的信息，我们会通过页面提示、交互流程、网站公告等方式另行向您说明信息收集的内容、范围和目的，以征得您的同意。 为了提供更为优质的服务，我们使用了一些第三方的服务，例如 Epic在线服务（EOS），在使用时请您您充分了解并同意，相应的服务条款例如《EPIC GAMES 隐私政策》、《EPIC GAMES 服务条款》\n信息共享和转让 第三方服务：为保障游戏安全稳定运行并实现特定功能，游戏中部分服务由我们的关联方或其他第三方提供服务。我们会审慎选择第三方和第三方服务，督促相关第三方按照本指引或另行与您达成的约定收集和使用您的个人信息。 个人信息转让：未经您的授权，我们不会向第三方转让您的个人信息。随着我们业务的持续发展，我们有可能进行合并、收购、资产转让等交易，我们将告知您相关情形，按照法律法规及不低于本指引所要求的标准继续保护或要求新的处理者继续保护您的个人信息。 个人信息的存储 信息存储的方式和期限：我们会通过安全的方式存储您的信息，包括本地存储（例如利用 APP 进行数据缓存）、数据库和服务器日志。一般情况下，我们只会在为实现服务目的所必需的时间内或法律法规规定的条件下存储您的个人信息。前述期限届满后，我们将对您的个人信息做删除或匿名化处理。 产品或服务停止运营时的通知：当我们的产品或服务发生停止运营的情况时，我们将根据相关法律法规规定进行公告通知，并依法保障您的合法权益。 您的权利 账号注销：您可以在【设置-注销账号】申请进行账号注销。 个人信息收集和使用规则查询：您可以在本产品内的设置界面随时查看产品个人信息收集和使用规则 未成年人保护 我们非常重视对未成年人个人信息的保护。\n根据相关法律法规的规定，若您是18周岁以下的未成年人，在使用我们的服务前，应事先取得您的家长或法定监护人的同意。\n根据相关法律法规的规定，若您是14周岁以下的儿童，在使用相关的产品或服务前，应当按照注册、使用流程，事先取得您的家长或法定监护人的同意，并由您的家长或法定监护人帮助您完成产品或服务注册流程，以便您能使用我们提供的产品或服务。\n遵守当地法律监管 您在使用我们所提供游戏服务过程中应当遵守当地相关的法律法规，并尊重当地的道德和风俗习惯。如果您的行为违反了当地法律法规或道德风俗，您应当为此独立承担责任。\n联系我们 您可以通过 feedback@tuclink.com 发送邮件与我们联系。\n其他 我们可能适时修订本隐私政策内容。\n我们有权在必要时变更本协议条款，您可以在我们游戏的相关网站查阅最新版本的协议条款。本协议条款变更后，如果您继续使用我们所提供的游戏及相关服务，即视为您已接受变更后的协议。\n我们提醒您：抵制不良游戏，拒绝盗版游戏；注意自我保护，谨防受骗上当；适度游戏益脑，沉迷游戏伤身；合理安排时间，享受健康生活。\n","permalink":"https://post.tuclink.com/zh/post/policy/privacypolicy/","summary":"Super Ball 隐私政策","title":"Super Ball 隐私政策"},{"content":" 介绍 Super Ball 功能开发切片\n本视频主要演示了游戏内的 UI 交互，欢迎进行任何形式的反馈 整体的思路是希望能让 UI 内容的切换选择可以尽可能的快捷，聚合\n目前阶段做了一些比较基础的美术设计，核心还是先以功能实现为主\n暴露了大部分 Godot 自带的画质调节选项，音频管线的控制等等\n语言适配问题 进行了简单的英语适配，就是遇到了一个在中文环境开发时最初没考虑到的问题\n侧边的按键采用了竖形排列，在汉语或东亚文化圈中竖型排列的方式并不少见，但是如果使用其他的语言，竖型排列就会遇到困难\n不仅是 Godot 本身没有暴露竖型语言的排列方法，实现需要额外的开发成本，可读性也会大大降低\n于是还是单独的做了另一版英文按键的排列方式，并实现了语言更改时的切换\n只是还有一个问题，按键文字会影响按钮的大小，若某一种语言某个单词的长度特别长又会导致按钮大小的失衡，就比如图中的 Control 按键\n可能比较简单的解决方式就是留出足够的空间，至少在 IU 设计时这需要考虑在内（每每此时就爱死了中文方块字的特性，可以很规整的控制文字的长度，简直强迫症的福音）\n按钮音频问题 在最初为按钮添加音效时不太想的好采用怎样的实现方案，因为 Godot 目前在 UI 音频配置方面还没有一套内置的方案，如果可以结合进目前 Godot 的 UI 主题系统中就完美了（虽然 Calinou 已经进行了实现只是合并乐观估计也得到 4.4 版本了）\n最后还是决定借助在上一篇文章中介绍过的插件 Resonate 为每种 UI 控件单独写一个脚本，并添加到每个 UI 控件上，相对来说会清晰一些，也方便对已有 UI 控件的升级\n其他更多的就是寻找合适的音效了，又算是一个体力活，不过在后续发现 itch 还是有挺多 UI 音效包的，也许就不用面临自己辛苦找半天，效果还不统一的问题了\n总结 UI 的实现，整体也属于技术方面并不存在太大的难度，但是相对来说会比较繁琐的一类\n总体来说目前的 UI 实现都是使用 Godot 自带的 UI 控件，不得不说 Godot 的 UI 系统还是很方便强大的，除了一些小Bug\n比如若使用 Godot 的 tr() 函数用于内容翻译，在切换多语言时就无法自动刷新，需要手动重新生成（当然这点可能不算 Bug）\n在使用 OptionButton 控件时，选项小窗无法和 UI 界面做到统一的分辨率 如果移动或是设置了显隐操作，选项小窗也无法跟随 OptionButton 一起变化，需要额外的手动适配 主题设置方面也存在一些问题 （主要还是 PopupMenu 的问题 问题报告）\n","permalink":"https://post.tuclink.com/zh/post/dev/dev-2/","summary":"游戏内的 UI 演示","title":"Godot：SB 开发快照（游戏 UI 演示）"},{"content":" set FFMPEG_PATH=C:\\Users\\Qianchen\\Music\\comp\\ffmpeg.exe @echo off setlocal enabledelayedexpansion set SRC_DIR=C:\\Users\\Qianchen\\Music\\comp\\comp_in set DST_DIR=C:\\Users\\Qianchen\\Music\\comp\\comp_out for %%i in (\u0026#34;%SRC_DIR%\\*.wav\u0026#34;) do ( set FILENAME=%%~ni set EXTENSION=%%~xi set OUTPUT=!DST_DIR!\\!FILENAME!.ogg \u0026#34;%FFMPEG_PATH%\u0026#34; -i \u0026#34;%%i\u0026#34; -vn -c:a libvorbis -qscale:a 5 \u0026#34;!OUTPUT!\u0026#34; ) FFMPEG_PATH：变量指向 ffmpeg.exe 的路径。\nSRC_DIR：变量指向待转换的音频文件所在目录。\nDST_DIR：变量指向转换后的音频文件存放目录。\n本脚本实现的了将 WAV 格式的音频文件转换为 OGG 格式的音频文件的功能，如有其他的需要可进行自行的调整\n","permalink":"https://post.tuclink.com/zh/post/tips/ffmpeg/","summary":"FFmpeg 音频转换","title":"FFmpeg 音频转换脚本"},{"content":" Super Ball 功能开发切片\n主要演示了游戏内的交互音效，欢迎进行任何形式的反馈 音频开发使用了 Resonate 插件\n这个插件一定程度上填补了 Godot 音频管理的薄弱，可以更方便的集中化管理音效和音乐\n说实话感觉音效方面的开发，技术方面并不存在太大的难度\n更多的问题在于音效的寻找上，音效相比图片等素材更不直观，作为一个个人开发者也无力进行音效制作\n在音效的寻找上耗费了很多的时间，同时还得进行多次的测试替换以找到最为契合的音效\n鼎立推荐 Audacity 这款开源软件可以进行快捷的音频调整\n例如素材的二次剪辑，降噪，渐入渐出，音量调节，乃至进行格式转换\n不过格式转换更好的方案还是使用 FFmpeg\n因为 Audacity 无法进行批量化的转换，但是 ffmpeg 因为没有 UI 所以使用起来还是会麻烦一些\n参考这篇博客\n通过这个脚本可以一键对 comp_in 内的音频文件进行转换，总体来说也算比较方便\n个人的素材使用主要是 itch 的免费音效，kenney 提供的免费音效，再次感谢无私的开源者们\n在 Godot 4.3 音乐管理方面又会带来 增强，会新增播放列表，和多个音频的分层播放，还是很期待的，也感谢 Godot 社区的贡献者们\n最后说说我的游戏，这是一个多人派对游戏，会有多个子玩法组成，目前在做的这个玩法会有一些类似《火箭联盟》有一些相似的底层设计思路\n当前完成了一些基础功能，包括本地联机的部分，能进行网络的匹配，不过还有一些 bug 需要修复，当前的局内规则也还没有进行开发，在全部完成之后会进行游戏性的测试\n其实我也知道一个网络游戏的开发对我来说还是会挺有挑战的，一个基于物理的网络游戏就更难了，不过也一步步的在向前挪动，说实话也并不知道最后是否能产生一些价值，为一些玩家带来快乐\n作为一个独立开发者不免有时会陷入迷茫，觉得无力，感到孤独。不过也没有其他的选择，唯有稳步的向前推进，后续如果有精力的话也许会谢谢整个游戏的策划思路。不过主要精力因该还是放在游戏的开发上\n之后会再放出一些其他的开发切片，不过可能不会出视频教程，当然看需求的话会在博客上写一些文本类的教程，和放出一些简单实用的脚本/着色器之类\nGodot 总的来说还是存在着很一些 bug 和不完善的地方，不过好在其拥有着一个庞大且活跃的社区。这能很大程度补上一些功能上的不足，也能感受到其在不断的变好\n对于引擎我并没有足够的实力进行贡献，但我想用其制作出满意的作品也算是某种程度的添砖加瓦\n总之 - Just do it.\n","permalink":"https://post.tuclink.com/zh/post/dev/dev-1/","summary":"游戏内的交互音效演示","title":"Godot：SB 开发快照（游戏声音演示）"},{"content":"章节导读 你会感到孤独吗？\n当然我相信每人都有着不同的感受，但确实有数据表明当代的我们正在整体性的滑向孤独\n明明现在的大部分人都居住在拥挤的城市之中，为什么处于社群中的我们还是会感到孤独呢？\n首先纵观人类历史，家庭一直是社会组成的基本单位，此外还衍生出了宗族，民族，乃至国家和文明\n长久以来群居一直是我们的生存方式，由此可以理解人类为什么会通过孤独这样的负面情绪向自己传递警示1\n马克思在18世纪写道“人是一切社会关系的总和”\n亚里士多德在公元前3世纪写道“人是一种社会性动物”\n即使相隔千年哲学家们也得出了相同的结论，人与社会的关系密不可分\n更不用说当下的地球拥有着人类出现以来最多的人口，且如此大量的人口还在进行聚集，形成了古人难以想象的庞大都市\n例如人民网在2023年3月报道“中国常住人口城镇化率突破65%”2，央视网报道“已有9省份镇化率超70%”3，根据韩联社报道“韩国更是有一半的人住在首都圈”4\n你看人群一直在进行汇聚，但是，另一方面与直觉相反的是，拥挤之下人与人之间的心灵距离却在变得越来越远\n越来越多的迹象表明当下的很多个体正在逐渐的滑向孤独\n例如韩联社2021年报道“逾二成韩国成年人有孤独倾向”5。2022年报道，“韩国孤独死人数近五年增四成”6。2023年报道“韩一人户家庭占35%创新高”7\n通过这些数据我们可以看到，当下的我们正处于一种热闹的孤寂之中\n自由的代价 原因 这种孤独感到底来自哪里，互联网能带来跨越地域的即时沟通，地铁中的人潮是如此的拥挤，无数的高楼拔地而起以极高的密度让我们住在了一起\n但是为什么现代人会渐渐的滑向孤独呢？\n沃尔泽认为“正是现代化的转变，带来了“孤独的自我”。其中最为突出的要素就是高度的“流动性”8\n“例如因为迁徙门槛的降低，淡化了对单一故土的忠诚，社群的归属不再固定于特定的地域”\n“人们的社会身份也在变得流动，一个人一生往往会有着很多份的工作”\n“亲密关系也在变得不再稳定，分居、离异和再婚比传统社会要高得多。意味着孩子们更有可能会从属于不同的家庭，也就难以从“一起生活的成年人哪里听到连续或同样的故事”由于家庭是个人的第一个社群，也是第一所种族认同与宗教信仰的“学校”，所以这种流动性必定具有反社群主义的后果”\n“对于现代的社群关系沃尔泽称之为“自愿型的社群”，与传统社群的最大差异在于我们拥有可以改变和退出的机会。因此我们很容易获得不同的身份认同或归属关系。但自由总是有代价的。因为越是容易获得和改变的关系，就是越不稳定的关系”\n“你会发现，真正“血肉相连”的，只是你和你自己。于是，那种无法分离、“血肉相连”的有机共同体就此成为一个过时的神话”\n总结而言这是一种“自由”带来的关系瓦解\n社会后果 人的归属感在“自由”的作用下在被消解\n而当归属丧失之后，人就会变的更加原子，会更加在意自己相关的事情，这会进一步加速社群的瓦解，进而促使个人主义的进一步兴盛\n人们将会表现的更为“自私”，社会将会表现的更为冷漠，个人之间的关系更多会基于竞争而非合作\n因此我们不免会落入萨特口中“他人即地狱”的困境\n陌生人社会之中人与人之间缺乏深度的了解相互之间只是符号般的存在，会进一步加强“主体性之争”，因为我们希望相比一个符号能更像一个人，由此就会产生更多的比较和嫉妒\n从另一个层面来说，这是现代化进精细分工和陌生人社会导致的一种必然\n大部分的个体被塑造成了一个精细化的工具，只能在特定的组织形态下才能发挥出真正的作用\n而脱离于体制的个人很难通过工具人与工具人的合作直接产生价值\n陌生人社会下个体之间不仅缺乏深度的了解更加缺乏相互的信任，也就更难建立起合作关系\n竞争就成为了更高优先级的选择，因为相互之间由于没有任何的纽带，他人的获益也不会为自己带来好处，例如宗族关系中所谓的“一人得道鸡犬升天”，在原子化的状态下这种期望就被瓦解了\n当然要说竞争能够带来更高的效率也没错，只是如果一切走向失控又会将许多生命卷入于无意义的损耗之中（当然这个另外一个话题了）\n原子化有时也不被看作是一种负面状态\n只是可以明确的是，当所有的关系被瓦解后人会进一步陷入孤立无援的状态之中，进而在风险和危机面前会变得更为脆弱\n反过来说群体最初的意义就是一种抵御风险的手段，聚集形成更加强大的威慑以抵御敌人或野兽的入侵，对于当下的原子个体也许就只能更多的依托于法律或制度的保护了\n生理后果 视频博主真理元素在一个幸福感研究的视频当中，通过调研数据论证了人际关系会比金钱带来更长久和稳定的幸福感\n2010 年研究人员综合分析了 148 项研究，涉及超过 30 万名参与者。他们发现平均来说有更强社交联系的人寿命也会更长，已婚男性寿命平均会比未婚男性长 12 年，女性则是长 7 年9\n还有一个在其它文章也被多次提及的调查研究，孤独对健康的危害相当于每天吸半包烟，另一份调查报告显示孤独人群心脏病风险平均增加 29%，中风风险增加 32%，认知衰退速度高出 20%，乃至带来更高的老年痴呆风险\n当然要注意的是孤独和独处不同，孤独更多指的是期望社交的欲望得不到满足。因此与亲密关系的质量也有着很大的联系，糟糕的婚姻对健康的负面影响可能会比离婚更大\n至于孤独对身体产生损害的原因，有研究表明造成这样负面影响的原因是因为在孤独状态时身体处于一种警惕的模式，需要应对随时到来的风险这会对身体带来逐渐的损害，而社交能让人产生安全感让身体处于一种平和的状态\n附近的消失 在寻找资料时我突然想起了B站UP主老蒋巨靠谱的视频，这两期视频主要探讨了项飙教授提出的“附近的消失”这一概念，并在此基础上进行了一些扩展和衍生讨论\n什么是附近的消失呢？\n我不知道你有没有那种租房的经历，就是那种隔间，一般来说可能会有四五户租客一起合租在一套房子里\n影视剧给我们的幻想是《老友记》《爱情公寓》，但事实上可能是最近的陌生人\n从某种意义上来说他者真正意义上的变成了一种“他者”，就像NPC一样，在你的生活中只是起到一个功能性的占位，没有任何多余的背景，他从哪来，有着怎样的家庭，是个怎样的人在这样的一种设定下一切都并不重要\n附近的人可能在物理意义上存在，但是在关系层面是消失的\n其主要原因还是沃尔泽提到的“流动性”问题\n在高流动状态下即使你花费精力与邻居们建立起了关系，也很有可能某天回家时同样的房间内就已经换成了一个新的邻居，一切又要重新开始\n从另一个层面来说，现代化社会下成长起来的我们，浸润在宏大叙事和个人主义之下，于此导致我们关注的问题往往是要么很大很远，要么很个人，反而对自己周边的人或事往往是忽视的\n项飙教授总结：当今的社会功能性过剩，生态性不足10\n虽然当前的社会运转能够很好的完成功能和效率，但是个人与社会之间的联系却变的更加薄弱了\n于是项飙教授提出了最初500米的想法，就是希望人们可以在生活中与那些被忽视的人建立更多的交流，例如遇到的清洁工、电梯中的邻居、小区的保安，以加强交流的方式重建附近\n只是结合之前的一些论点，陌生化社会我觉得很难通过倡议去进行解决，或是逆转\n事实上，我们的孤独感既谈不上普遍，亦非“人类境况”的一部分，而是我们这个变动不安的、个人主义盛行的社会所导致的一个不可避免的后果11\n关系的瓦解 老蒋在视频中举例，魔兽世界工会中的玩家，是一个二三十人的小团体，大家在一起长时间的高频交互和语言交流，但是这也很难称得上是一种稳定的关系，因为可能随时就会有人退游，然后这辈子再也见不到他12\n这像是一种社会关系上的死亡，在这个世界上就此消失\n对于这种可以自由选择加入，但又较为容易瓦解的社群关系，与沃尔泽指出的一模一样\n“自由总是有代价的。因为越是容易获得和改变的关系，就是越不稳定的关系。比如你很喜欢自己参加的俱乐部，但是因为要搬家到另一个城市，就不得不退出。如果其他人也有自己的原因放弃了，那俱乐部就只好解散”13\n所以当下的我们所面临的将是来自内外社群关系的双重瓦解\n内部社群的瓦解在于快速的城市化发展打碎了一些原有家庭的结构，从大家庭变成了小家庭，亲友之间一年见面的次数也会变的极为有限\n而离婚和不婚的比例提高，更是进一步瓦解了家庭这个原本最为基础的关系结构，就像是个人失去了根系\n外部的社群瓦解老蒋在视频中也提到了他的例子，就是物理上附近的消失，例如中国城市中沿街店铺的消解14\n记得小时候逛街就正如这个词本身，逛的是街是店面\n但现在都被逐渐替换成了综合体，店铺本身大多也不再是围绕人展开，你面向的不是一个固定的老板，而是随时可能变化的职员\n甚至你都不用面对这些职员，可以直接扫码点餐或是外卖送达\n而邻居呢，相互之间最大的见面机会大多也被局限在了电梯之中的几十秒内\n你看就连这些边缘的社交关系都在开始变的更加的不稳定被消解\n我想这可以解释为韦伯所说的“工具理性”所带来的影响，是效率追求下所带来的机械般的冰冷感。社区不再是基于人文的自然产生，而是理性规划的被动适应\n当然自由和效率也是很多人追求和享受的，所以失去了社群关系会有什么后果呢？桑德尔认为\n个人并不是先于社会存在的”原子“。作为个体的”自我“不是凭空产生的，而是在社会关系中被造就的。社群不只是工具，也不只是合作团队中的情感依赖，社群在根本意义上定义了”你是谁“，它塑造了你的身份认同、生活理想、道德感与责任意识15\n换言之失去社群关系的原子个人，会更容易出现意义感缺失的现象，对自我的存在价值和社会责任产生怀疑\n因为从某种意义来说个体的存在价值感和责任感就来源于他人的认可和反馈\n陌生的我们 老蒋在视频中还提到了另外的一个问题，在陌生人社会除了会有我是谁的问题，还会有你是谁的问题16\n因为相互之间是完全陌生的，所以会需要花费额外的很多精力在信任的建立上\n其中最明显的展示就是在找工作上，你需要重复的去推销自己去重复的展示自己的特点和优势，才能让他人知道你是谁\n更可怕是“工具理性”还会再次介入，例如“人力资源”这个词就进行了很好的揭露了在“工具理性”17塑造下人的本质，是矿是耗材是某种商品\n所有的一切都会被拿来进行对比，人会被数据化变成KPI，其他的所有一切都会被忽视，在此之下人要么接受规训要么承受否定\n除了这种在竞争和淘汰下的疲惫，还有来自标签的片面化\n标签化是一种快速认知事物的手段，但是其问题在于只用标签化去定义自己定义他人\n其问题类似于萨特指出的人与人之间的主体之争，本质而言我们因该通过他人本身去了解他人，但是一些情况却变成了通过标签去反向定义他人，这很容易造成误解和沟通的阻碍\n而除了对他人的异化，更严重的是将他人给予的标签反向作用在了自己的身上，从而扼杀了自己的可能性\n用萨特的话来说“存在先于本质”\n人永远不会“是”什么，而是永远都在“成为”什么18\n刘擎教授指出对他人既要进行概括做一般化抽象，同时又做到差异化处理19，这是建立深度关系的前提\n作为一般化思考，我们常说“没人懂我”，正是因为大部分的关系都只停留在了标签化的层面\n而深层次的理解，就需要放弃一部分已有的认知或是想象，不要想着去定义他人，而是去接纳，从他人本身去了解他人\n结语 作为最后的总结，现代化带来的流动性对深度关系的破坏是这个时代下孤独感的主要来源，换句话来说这是自由的代价\n一般很多讲述孤独的文章或是视频末尾总是会给出一个解决孤独的办法，只不过在我看来人生总是可遇而不可求的\n罗翔老师在一个视频中引述了爱比克泰德的话“我们登上的并非我们所选择的舞台，演出并非我们所选择的剧本”20\n个人能及的也只有做好能做一切，既然一切总是相对的，如果无法避免孤独，那至少因该享受自由\n补充 本来因该还有一章讲的是文化多元性对集体性的消解，从而致的个体归属感缺失，以及于此衍生出的，垂直细分型的社交模式，例如搭子文化。但内容梳理时总感觉还是有一些问题于是就此删去，在此作为简短补充\n还有一个在正文中没有展开的部分就是孤独的生理性层面，其作为一种生理性需求，是会对身体产生直接影响的，且作为本我层的东西，更底层于自我也就是说你无法通过理性手段去进行解决或压制21\n最后补充一个有趣的观察，刘擎教授在视频中询问孤独的反义词是什么的时候弹幕给出了很多答案，我想这也许同样能作为解决孤独的答案“交流、充实、完满、联系、温暖、理解、共鸣、幸福、归属、爱情、目标、陪伴、充盈”22\n参考\nKurzgesagt科普 https://www.bilibili.com/video/BV1UT41117yR/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=93\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n超65%，城镇化进入“下半场” http://paper.people.com.cn/rmrbhwb/html/2023-03/29/content_25972874.htm#\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n31省份最新城镇化率：9省份超70%，这10个省份城镇人口最多 https://news.cctv.com/2023/05/19/ARTI0AYSIeZl2Dq2YKQHTXTg230519.shtml\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n统计：韩国首都圈人口首占全国人口半数 | 韩联社 https://cn.yna.co.kr/view/ACK20200828003800881\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n统计：逾二成韩国成年人有孤独倾向 | 韩联社 https://cn.yna.co.kr/view/ACK20211210003500881?section=search\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n统计：韩国孤独死人数近五年增四成 | 韩联社 https://cn.yna.co.kr/view/ACK20221214003700881?section=search\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n统计：韩国2022年一人户家庭占35%创新高 | 韩联社 https://cn.yna.co.kr/view/ACK20231212003000881?section=society/index\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《刘擎西方现代思想讲义》p238\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nVeritasium真理元素 https://www.bilibili.com/video/BV1Zw411V7Gm/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=419\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n项飙 https://www.bilibili.com/video/BV15g411i7Pq/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=130\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《大问题》P222\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n老蒋 https://www.bilibili.com/video/BV1Pz4y1k7pu/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=121\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《刘擎西方现代思想讲义》p239\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n老蒋 https://www.bilibili.com/video/BV1Hp4y1W7wY/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=355\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《刘擎西方现代思想讲义》p230、232\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n老蒋 https://www.bilibili.com/video/BV1Hp4y1W7wY/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=1288\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《刘擎西方现代思想讲义》p56\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《刘擎西方现代思想讲义》p104\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n刘擎 https://www.bilibili.com/video/BV1P8411t7Gm/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=940\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n罗翔 https://www.bilibili.com/video/BV1HP4y1b7jv/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=183\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTIANYU2FM https://www.bilibili.com/video/BV1Yg4y1y72n/?vd_source=67b8986d6aba57f2d6092cd1353eebb1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n刘擎 https://www.bilibili.com/video/BV1Kr4y1g7q2/?share_source=copy_web\u0026vd_source=a6722d36223d7517d3f305cd449868e2\u0026t=188\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://post.tuclink.com/zh/post/article/lonely/","summary":"章节导读 你会感到孤独吗？ 当然我相信每人都有着不同的感受，但确实有数据表明当代的我们正在整体性的滑向孤独 明明现在的大部分人都居住在拥挤的城市之","title":"热闹的孤寂-拥挤的城市与原子的个体"},{"content":"print(\u0026#34;Hello World\u0026#34;) 强行换行 图片设置\n图片（未压缩） 图片（压缩） 图片（压缩设置宽高） 第一章 尘封 新生\r日期: 2024-05-07\r\u0026nbsp;\r标签:\r#故事\u0026nbsp;\r昏沉的醒过来，视野中还闪烁着彩色噪点，眼前的景象随着闪烁的绿色灯光被间断的点亮 隐约能辨认出，眼前堆满了各类杂乱机械部件，自己似乎被放在了一张 ......\r文字居左\n文字居中\n文字居右\n图标\n音乐测试 模型添加测试 RAW 文件测试 RAW 文件\nShader 测试 Bilibili 视频测试 ","permalink":"https://post.tuclink.com/zh/article/","summary":"print(\u0026#34;Hello World\u0026#34;) 强行换行 图片设置 图片（未压缩） 图片（压缩） 图片（压缩设置宽高） 第一章 尘封 新生 日期: 2024-05-07 \u0026nbsp; 标签: #故事\u0026nbsp; 昏沉的醒过来，视野中还闪烁","title":"Hello World"}]